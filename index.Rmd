---
title: "Computational Musicology Portfolio"
author: "Michael Okyere"
date: "10-2-2021"
#output: html_document
output: 
  flexdashboard::flex_dashboard:
    storyboard: true
    #theme: darkly
    theme: flatly
    #vertical layout: fill
    logo: icons/logoMO.png
    favicon: icons/logoMOB.png
    source_code: "https://github.com/mic-oky/cmpmusportfolio"
    target: _blank
    #social: [ "linkedin" ]
#runtime: shiny
---

<!-- Thanks for stopping by at my Computational Musicology Portfolio! Beware, the code is pretty messy at this point -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(dplyr)
library(spotifyr)
library(ggplot2)
library(compmus)
library(plotly)
library(reshape2)
library(crosstalk)
library(d3scatter)
library(grid)
library(gridExtra)
library(ggrepel)
library(htmlwidgets)
library(slickR)
library(svglite)
library(DT)
library(stringi)

library(flexdashboard)
library(shinydashboard)
library(shiny)

library(patchwork)

Sys.setlocale(category = "LC_ALL", locale = "English_United States.1252")
options(scipen = 999, encoding = "UTF-8")
```

```{css style, echo = FALSE}
.navbar-inverse {
    background-color: rgba(29, 185, 84, 1);
    #background-color: #1a242f;
    border-color: transparent;
}

.section.sidebar {
  top: 60px;
  background-color: rgba(29, 185, 84, 1);
}

.bg-success {
  background-color: rgba(29, 185, 84, 1);
}

.bg-primary {
  background-color: rgba(191, 191, 191, 0.7);
}

.storyboard-nav .sbframelist { 
  overflow : scroll; 
}

.storyboard-nav .sbframelist ul li {
  transition: 0.3s;
}

.storyboard-nav .sbframelist ul li.active {
  transition: 0.3s;
}

.storyboard-nav .sbframelist ul li.active {
  #background-color: rgba(191, 191, 191, 0.7);
  background-color: rgba(29, 185, 84, 0.8);
  background-image: url('icons/COVIDW/COVID-19.png');
  background-repeat: no-repeat;
  background-position: 130% -310%;
  background-size: auto;
  background-blend-mode: soft-light;
}



.storyboard-nav .sbframelist ul li:hover {
  background-color: rgba(47, 71, 79, 0.7) !important;
  color: white;
}

.storyboard-nav .sbframelist ul li.active:hover {
  #background-color: rgba(44, 62, 80, 0.7);
  #background-color: #3e8e41;
  background-color: rgba(29, 185, 84, 1) !important;
  color: white;
  #background-image: url('icons/COVIDW/COVID-19.png');
  background-image: url('icons/COVIDB/COVID-19.png');
  background-repeat: no-repeat;
  background-position: 130% -310%;
  background-size: auto;
  background-blend-mode: soft-light;
}


# tabBox

.nav-tabs-custom > .nav-tabs > li.active {
    background-color: rgba(29, 185, 84, 1) !important;
    color: #fff;
    # font-weight: 300;
    # font-size: 14px;
    # border-radius: 0;
    # padding: 3px 10px 5px;
    # text-transform: none;

.nav-tabs-custom > .nav-tabs > li:hover > a {
    background-color: rgba(47, 71, 79, 0.7) !important;
    color: #fff;
    # font-weight: 300;
    # font-size: 14px;
    # border-radius: 0;
    # padding: 3px 10px 5px;
    # text-transform: none;
}

.nav-tabs-custom > .nav-tabs > li.active > a {
    background-color: rgba(29, 185, 84, 0.7) !important;
    color: #fff;
    # font-weight: 300;
    # font-size: 14px;
    # border-radius: 0;
    # padding: 3px 10px 5px;
    # text-transform: none;
}

.nav-tabs-custom > .nav-tabs > li.active:hover > a {
    background-color: rgba(29, 185, 84, 1) !important;
    color: #fff;
    # font-weight: 300;
    # font-size: 14px;
    # border-radius: 0;
    # padding: 3px 10px 5px;
    # text-transform: none;
}


# Details drop down
details[open] > summary:first-of-type {
    list-style-type: disclosure-open;
}

details > summary:first-of-type {
    display: list-item;
    counter-increment: list-item 0;
    list-style: inside disclosure-closed;
    list-style-position: inside;
    list-style-image: initial;
    list-style-type: disclosure-closed;
}

:focus {
    outline: -webkit-focus-ring-color auto 1px;
    outline-color: -webkit-focus-ring-color;
    outline-style: auto;
    outline-width: 1px;
}

summary {
    display: block !important;
}

details[open] ul li {
    
}

summary:hover {
    background-color: rgba(29, 185, 84, 1) !important;
    color: white;
    transition: 0.3s;
}

```

<!-- Code for corpus -->

```{r Create Corpus, include=FALSE, cache=TRUE}
#Read filenames of csv's
files <- list.files(path="csvPlaylists/", pattern="week+.*csv")

#Create list of data frame per week without the ".csv" part 
weeks <- substr(files,1,nchar(files)-4)
featuresweeks <- paste0("features", substr(files,1,nchar(files)-4))

#Load all files in a loop using weeks data frame. 
#(I wish I new about purrr a little bit earlier... but this gets the job done)
for(i in weeks){
    filepath <- file.path("csvPlaylists",paste(i,".csv",sep=""))
    #assign csv to variable df
    df <- read.csv(filepath)
    #df <- read_csv(filepath)
    
    #clean data frame: remove header, set 1st row as header, remove 1st row
    names(df) <- NULL 
    names(df) <- df[1,] 
    
    #Create year and week variables and assign week and year to playlist
    df$year[i] <- str_sub(i, -4)
    df$week[i] <- str_remove(substr(i,1,nchar(i)-5), "week")

    #Remove 1st row (NA's)    
    df <- df[-1,]    
    
    #Select first 50 values (Top 50) of df 
    df <- head(df,50)
    
    #Loop-in-loop: for each week in df #Nested-loop: code takes a long time to run (again purrr...)
    for(j in df){
        #Set variables to correct datatype
        df$Position <- as.integer(as.character(df$Position))
        df$Streams <- as.integer(as.character(df$Streams))
        #Extract Spotify URI from URL
        df$URI <- str_replace(df$URL, "https://open.spotify.com/track/", "")
        
        #Create variable "week*_20**" and assign current df
        assign(paste0("", i), df)
        #Create variable "featuresweek*_20**" and assign Spotify audiofeatures
        assign(paste0("features", i),cbind(get_track_audio_features(df$URI), 
                                           year = str_sub(i, -4),
                                           week = str_remove(substr(i,1,nchar(i)-5), "week"))
               )
      
    }

}
```

```{r Data Wrangling, include=FALSE}
#Splitting all weeks to their respective dataframe
weeks2021 <- weeks[grep("^week.*_2021$", weeks)]
weeks2020 <- weeks[grep("^week.*_2020$", weeks)]
weeks2019 <- weeks[grep("^week.*_2019$", weeks)]
fweeks2021 <- featuresweeks[grep("^featuresweek.*_2021$", featuresweeks)]
fweeks2020 <- featuresweeks[grep("^featuresweek.*_2020$", featuresweeks)]
fweeks2019 <- featuresweeks[grep("^featuresweek.*_2019$", featuresweeks)]

#Sorting all weeks chronologically
as.numeric(gsub('^week([0123456789]*)\\_2021$','\\1',weeks2021))->sort2021
sorted_weeks2021 <- weeks2021[order(sort2021)]
sorted_fweeks2021 <- fweeks2021[order(sort2021)]

as.numeric(gsub('^week([0123456789]*)\\_2020$','\\1',weeks2020))->sort2020
sorted_weeks2020 <- weeks2020[order(sort2020)]
sorted_fweeks2020 <- fweeks2020[order(sort2020)]

as.numeric(gsub('^week([0123456789]*)\\_2019$','\\1',weeks2019))->sort2019
sorted_weeks2019 <- weeks2019[order(sort2019)]
sorted_fweeks2019 <- fweeks2019[order(sort2019)]
```

```{r Summarizing features, include=FALSE, cache=TRUE}
summary2019 = list()
summary2020 = list()
summary2021 = list()
fsummary2019 = list()
fsummary2020 = list()
fsummary2021 = list()

# Extracting featuredata from sorted list
for(l in sorted_fweeks2019){
    dat <- get(l) %>%
        summarize(mean_dance = mean(danceability),
                  mean_energy = mean(energy),
                  mean_key = mean(key),
                  mean_loudness = mean(loudness),
                  mean_mode = mean(mode),
                  mean_speechiness = mean(speechiness),
                  mean_acousticness = mean(acousticness),
                  mean_instrumentalness = mean(instrumentalness),
                  mean_liveness = mean(liveness),
                  mean_valence = mean(valence),
                  mean_tempo = mean(tempo),
                  mean_duration_minute = mean(duration_ms/1000/60),
                  year = max(year)
                  )
    fsummary2019[[l]] <- dat 
}

for(l in sorted_fweeks2020){
    dat <- get(l) %>%
        summarize(mean_dance = mean(danceability),
                  mean_energy = mean(energy),
                  mean_key = mean(key),
                  mean_loudness = mean(loudness),
                  mean_mode = mean(mode),
                  mean_speechiness = mean(speechiness),
                  mean_acousticness = mean(acousticness),
                  mean_instrumentalness = mean(instrumentalness),
                  mean_liveness = mean(liveness),
                  mean_valence = mean(valence),
                  mean_tempo = mean(tempo),
                  mean_duration_minute = mean(duration_ms/1000/60),
                  year = max(year))
    fsummary2020[[l]] <- dat 
}

for(l in sorted_fweeks2021){
    dat <- get(l) %>%
        summarize(mean_dance = mean(danceability),
                  mean_energy = mean(energy),
                  mean_key = mean(key),
                  mean_loudness = mean(loudness),
                  mean_mode = mean(mode),
                  mean_speechiness = mean(speechiness),
                  mean_acousticness = mean(acousticness),
                  mean_instrumentalness = mean(instrumentalness),
                  mean_liveness = mean(liveness),
                  mean_valence = mean(valence),
                  mean_tempo = mean(tempo),
                  mean_duration_minute = mean(duration_ms/1000/60),
                  year = max(year))
    fsummary2021[[l]] <- dat 
}

# Extracting low-level top track data from sorted list
for(l in sorted_weeks2019){
    dat <- get(l) %>%
        summarize(mean_streams = mean(Streams),
                  min_streams = min(Streams),
                  max_streams = max(Streams),
                  top_track = head(paste(`Track Name`,"-" , Artist), 1)
                  )
    summary2019[[l]] <- dat
}

for(l in sorted_weeks2020){
    dat <- get(l) %>%
        summarize(mean_streams = mean(Streams),
                  min_streams = min(Streams),
                  max_streams = max(Streams),
                  top_track = head(paste(`Track Name`,"-" , Artist), 1)
                  )
    summary2020[[l]] <- dat
}

for(l in sorted_weeks2021){
    dat <- get(l) %>%
        summarize(mean_streams = mean(Streams),
                  min_streams = min(Streams),
                  max_streams = max(Streams),
                  top_track = head(paste(`Track Name`,"-" , Artist), 1)
                  )
    summary2021[[l]] <- dat
}

# Binding rows 
fdata2019 <- dplyr::bind_rows(fsummary2019)
fdata2020 <- dplyr::bind_rows(fsummary2020)
fdata2021 <- dplyr::bind_rows(fsummary2021)
sdata2019 <- dplyr::bind_rows(summary2019)
sdata2020 <- dplyr::bind_rows(summary2020)
sdata2021 <- dplyr::bind_rows(summary2021)


data2019 <- cbind(week_year = str_remove(sorted_weeks2019, "_2019"),fdata2019, sdata2019)
data2020 <- cbind(week_year = str_remove(sorted_weeks2020, "_2020"),fdata2020, sdata2020)
data2021 <- cbind(week_year = str_remove(sorted_weeks2021, "_2021"),fdata2021, sdata2021)

dataAll <- dplyr::bind_rows(data2019, data2020, data2021)


```

```{r Full features, include = FALSE, cache=TRUE}
all2019f = list()
all2019 = list()
all2020f = list()
all2020 = list()
all2021f = list()
all2021 = list()

for(m in sorted_fweeks2019){
    datm <- get(m) %>%
        summarize(danceability,energy,key,loudness,mode,speechiness,acousticness,instrumentalness,
                  liveness,valence,tempo,duration_minute = duration_ms/1000/60, year, week = as.factor(week),
                  mean_dance = mean(danceability),
                  mean_energy = mean(energy),
                  mean_key = mean(key),
                  mean_loudness = mean(loudness),
                  mean_mode = mean(mode),
                  mean_speechiness = mean(speechiness),
                  mean_acousticness = mean(acousticness),
                  mean_instrumentalness = mean(instrumentalness),
                  mean_liveness = mean(liveness),
                  mean_valence = mean(valence),
                  mean_tempo = mean(tempo),
                  mean_duration_minute = mean(duration_ms/1000/60))
    all2019f[[m]] <- datm
}

for(o in sorted_weeks2019){
    dat <- get(o) %>%
        summarize(Position, Streams, `Track Name`, Artist, Streams, year, week,
                  mean_streams = mean(Streams),
                  min_streams = min(Streams),
                  max_streams = max(Streams),
                  top_track = head(paste(`Track Name`,"-" , Artist), 1)
                  )
    all2019[[o]] <- dat
}

for(m in sorted_fweeks2020){
    datm <- get(m) %>%
        summarize(danceability,energy,key,loudness,mode,speechiness,acousticness,instrumentalness,
                  liveness,valence,tempo,duration_minute = duration_ms/1000/60, year, week = as.factor(week),
                  mean_dance = mean(danceability),
                  mean_energy = mean(energy),
                  mean_key = mean(key),
                  mean_loudness = mean(loudness),
                  mean_mode = mean(mode),
                  mean_speechiness = mean(speechiness),
                  mean_acousticness = mean(acousticness),
                  mean_instrumentalness = mean(instrumentalness),
                  mean_liveness = mean(liveness),
                  mean_valence = mean(valence),
                  mean_tempo = mean(tempo),
                  mean_duration_minute = mean(duration_ms/1000/60))
    all2020f[[m]] <- datm
}

for(o in sorted_weeks2020){
    dat <- get(o) %>%
        summarize(Position, Streams, `Track Name`, Artist, Streams, year, week,
                  mean_streams = mean(Streams),
                  min_streams = min(Streams),
                  max_streams = max(Streams),
                  top_track = head(paste(`Track Name`,"-" , Artist), 1)
                  )
    all2020[[o]] <- dat
}

for(m in sorted_fweeks2021){
    datm <- get(m) %>%
        summarize(danceability,energy,key,loudness,mode,speechiness,acousticness,instrumentalness,
                  liveness,valence,tempo,duration_minute = duration_ms/1000/60, year, week = as.factor(week),
                  mean_dance = mean(danceability),
                  mean_energy = mean(energy),
                  mean_key = mean(key),
                  mean_loudness = mean(loudness),
                  mean_mode = mean(mode),
                  mean_speechiness = mean(speechiness),
                  mean_acousticness = mean(acousticness),
                  mean_instrumentalness = mean(instrumentalness),
                  mean_liveness = mean(liveness),
                  mean_valence = mean(valence),
                  mean_tempo = mean(tempo),
                  mean_duration_minute = mean(duration_ms/1000/60))
    all2021f[[m]] <- datm
}

for(o in sorted_weeks2021){
    dat <- get(o) %>%
        summarize(Position, Streams, `Track Name`, Artist, Streams, year, week,
                  mean_streams = mean(Streams),
                  min_streams = min(Streams),
                  max_streams = max(Streams),
                  top_track = head(paste(`Track Name`,"-" , Artist), 1)
                  )
    all2021[[o]] <- dat
}

big_all2019f <- dplyr::bind_rows(all2019f)
big_all2019 <- dplyr::bind_rows(all2019)

big_all2020f <- dplyr::bind_rows(all2020f)
big_all2020 <- dplyr::bind_rows(all2020)

big_all2021f <- dplyr::bind_rows(all2021f)
big_all2021 <- dplyr::bind_rows(all2021)

join_big2019 <- dplyr::bind_cols(big_all2019f, big_all2019)
join_big2020 <- dplyr::bind_cols(big_all2020f, big_all2020)
join_big2021 <- dplyr::bind_cols(big_all2021f, big_all2021)

corpus_df <- dplyr::bind_rows(join_big2019,join_big2020,join_big2021)
```

```{r COVID-19 dataset, include = FALSE}
# Read COVID-CSV
covid_dat_2020 <- read.csv("csvCOVID/COVID-19_2020.csv", header = TRUE, sep = ";")
covid_dat_2021 <- read.csv("csvCOVID/COVID-19_2021.csv", header = TRUE, sep = ";")

# Create zero dataframe for 2019 (Since no COVID data available from RIVM till Feb 2020)
covid_dat_2019 <- data.frame(#week = c(45:52),
                             week = c(1:52),
                             hospital_admission = c(0),
                             cum_hospital_admission = c(0),
                             deceased = c(0),
                             cum_deceased = c(0),
                             total_reported = c(0),
                             cum_total_reported = c(0)
                             )

# Rename weeknumbers to indicate year + factor weeks to avoid grouping by week
covid_dat_2019y <- covid_dat_2019
covid_dat_2019y$week_year <- paste0(covid_dat_2019$week, "_2019")
covid_dat_2019y$week_year <- factor(covid_dat_2019y$week_year, levels = covid_dat_2019y$week_year)

covid_dat_2019y$week <- factor(covid_dat_2019y$week, levels = covid_dat_2019y$week)
covid_dat_2019y$year <- 2019


covid_dat_2020y <- covid_dat_2020
covid_dat_2020y$week_year <- paste0(covid_dat_2020$week, "_2020")
covid_dat_2020y$week_year <- factor(covid_dat_2020y$week_year, levels = covid_dat_2020y$week_year)

covid_dat_2020y$week <- factor(covid_dat_2020y$week, levels = covid_dat_2020y$week)
covid_dat_2020y$year <- 2020


covid_dat_2021y <- covid_dat_2021
covid_dat_2021y$week_year <- paste0(covid_dat_2021$week, "_2021")
covid_dat_2021y$week_year <- factor(covid_dat_2021y$week_year, levels = covid_dat_2021y$week_year)

covid_dat_2021y$week <- factor(covid_dat_2021y$week, levels = covid_dat_2021y$week)
covid_dat_2021y$year <- 2021


# Combine dataframes + factor weeks to avoid grouping by week
covid_daty <- dplyr::bind_rows(covid_dat_2019y,covid_dat_2020y,covid_dat_2021y)
#covid_daty$week <- factor(covid_daty$week, levels = covid_daty$year)
covid_daty$week_year <- factor(covid_daty$week_year, levels = covid_daty$week_year)
#covid_daty$week <- as.character(covid_daty$week)
#covid_daty$week <- factor(covid_daty$week, ordered = is.ordered(covid_daty$week))

#comb_data <- dplyr::bind_rows(dataAll, covid_daty)
```

```{r Combining Datasets, include = FALSE}

#NOTE temporarily removed first column (weekXX), can rename later if needed, and added zero row for spotify week 7, will add later
#NOTE2 first column not very necessary as week_year and week are present already
#NOTE3 added week 7
#comb_data <- dplyr::bind_cols(rbind(dataAll[-1], 0), covid_daty)
comb_data <- dplyr::bind_cols(dataAll[-1], covid_daty)
comb_data <- tibble::rowid_to_column(comb_data, "ID")

# counting top_tracks weeks on number 1 spot
#toptraxweekly <- as.data.frame((comb_data$top_track$week_year) , stringsAsFactors = F)
toptraxweekly <- as.data.frame((comb_data %>% select(top_track, week_year, max_streams)) , stringsAsFactors = F)
toptraxcount <- comb_data %>% count(top_track)
toptraxtotstreams <- comb_data %>% group_by(top_track) %>% summarise(tot_streams = sum(max_streams))
traxjoin <- left_join(toptraxweekly, toptraxcount)
traxjoin <- left_join(traxjoin, toptraxtotstreams)

comb_data_trax <- left_join(comb_data, traxjoin)
```

```{r chordogram, include = FALSE}
circshift <- function(v, n) {
  if (n == 0) v else c(tail(v, n), head(v, -n))
}

#      C     C#    D     Eb    E     F     F#    G     Ab    A     Bb    B
major_chord <-
  c(   1,    0,    0,    0,    1,    0,    0,    1,    0,    0,    0,    0)
minor_chord <-
  c(   1,    0,    0,    1,    0,    0,    0,    1,    0,    0,    0,    0)
seventh_chord <-
  c(   1,    0,    0,    0,    1,    0,    0,    1,    0,    0,    1,    0)

major_key <-
  c(6.35, 2.23, 3.48, 2.33, 4.38, 4.09, 2.52, 5.19, 2.39, 3.66, 2.29, 2.88)
minor_key <-
  c(6.33, 2.68, 3.52, 5.38, 2.60, 3.53, 2.54, 4.75, 3.98, 2.69, 3.34, 3.17)

chord_templates <-
  tribble(
    ~name, ~template,
    "Gb:7", circshift(seventh_chord, 6),
    "Gb:maj", circshift(major_chord, 6),
    "Bb:min", circshift(minor_chord, 10),
    "Db:maj", circshift(major_chord, 1),
    "F:min", circshift(minor_chord, 5),
    "Ab:7", circshift(seventh_chord, 8),
    "Ab:maj", circshift(major_chord, 8),
    "C:min", circshift(minor_chord, 0),
    "Eb:7", circshift(seventh_chord, 3),
    "Eb:maj", circshift(major_chord, 3),
    "G:min", circshift(minor_chord, 7),
    "Bb:7", circshift(seventh_chord, 10),
    "Bb:maj", circshift(major_chord, 10),
    "D:min", circshift(minor_chord, 2),
    "F:7", circshift(seventh_chord, 5),
    "F:maj", circshift(major_chord, 5),
    "A:min", circshift(minor_chord, 9),
    "C:7", circshift(seventh_chord, 0),
    "C:maj", circshift(major_chord, 0),
    "E:min", circshift(minor_chord, 4),
    "G:7", circshift(seventh_chord, 7),
    "G:maj", circshift(major_chord, 7),
    "B:min", circshift(minor_chord, 11),
    "D:7", circshift(seventh_chord, 2),
    "D:maj", circshift(major_chord, 2),
    "F#:min", circshift(minor_chord, 6),
    "A:7", circshift(seventh_chord, 9),
    "A:maj", circshift(major_chord, 9),
    "C#:min", circshift(minor_chord, 1),
    "E:7", circshift(seventh_chord, 4),
    "E:maj", circshift(major_chord, 4),
    "G#:min", circshift(minor_chord, 8),
    "B:7", circshift(seventh_chord, 11),
    "B:maj", circshift(major_chord, 11),
    "D#:min", circshift(minor_chord, 3)
  )

key_templates <-
  tribble(
    ~name, ~template,
    "Gb:maj", circshift(major_key, 6),
    "Bb:min", circshift(minor_key, 10),
    "Db:maj", circshift(major_key, 1),
    "F:min", circshift(minor_key, 5),
    "Ab:maj", circshift(major_key, 8),
    "C:min", circshift(minor_key, 0),
    "Eb:maj", circshift(major_key, 3),
    "G:min", circshift(minor_key, 7),
    "Bb:maj", circshift(major_key, 10),
    "D:min", circshift(minor_key, 2),
    "F:maj", circshift(major_key, 5),
    "A:min", circshift(minor_key, 9),
    "C:maj", circshift(major_key, 0),
    "E:min", circshift(minor_key, 4),
    "G:maj", circshift(major_key, 7),
    "B:min", circshift(minor_key, 11),
    "D:maj", circshift(major_key, 2),
    "F#:min", circshift(minor_key, 6),
    "A:maj", circshift(major_key, 9),
    "C#:min", circshift(minor_key, 1),
    "E:maj", circshift(major_key, 4),
    "G#:min", circshift(minor_key, 8),
    "B:maj", circshift(major_key, 11),
    "D#:min", circshift(minor_key, 3)
  )
```

<!-- Code for dashboard -->

<!-- Page 1 (additional pages (optional) can add extra frames) -->

<!-- Frame 11 -->

### `r shiny::icon("exclamation-triangle")` ***NEW!***<br>11. *"Tigers"* by Bilal Wahib has a tempo of **112 BPM**

```{r, include = FALSE, cache = TRUE}
tiger <- get_tidy_audio_analysis("7jnaow1bGpKO2VkgtYE8Vv")

p11_1 <- tiger %>%
  tempogram(window_size = 8, hop_size = 1, cyclic = FALSE) %>%
  ggplot(aes(x = time, y = bpm, fill = power)) +
  geom_raster() +
  scale_fill_viridis_c(guide = "none") +
  labs(title = "Tempogram", subtitle = "Tigers - Bilal Wahib",  x = "Time (s)", y = "Tempo (BPM)") +
  theme_classic()


p11_2 <- tiger %>%
  tempogram(window_size = 8, hop_size = 1, cyclic = TRUE) %>%
  ggplot(aes(x = time, y = bpm, fill = power)) +
  geom_raster() +
  scale_fill_viridis_c(guide = "none") +
  labs(title = "Tempogram (cyclic)", subtitle = "Tigers - Bilal Wahib", x = "Time (s)", y = "Tempo (BPM)") +
  theme_classic()

```

```{r, echo=FALSE}
# px_1 <- xmlSVG({show(p11_1)}, standalone = TRUE)
# 
# px_2 <- xmlSVG({show(p11_2)}, standalone = TRUE)
# 
# slickR(list(px_1, px_2), height = 200, width = "95%")

settings <- settings(dots = TRUE, adaptiveHeight = FALSE)

plist <- list("Rplot1.png", "Rplot2.png")

slickR(plist, height = "80", width = "80%") + settings

```

```{css}
.chart-stage .html-widget-static-bound {
    width: 95% !important;
    height: 100% !important;
}
```

***

Another popular track in the corpus is "Tigers" by Bilal Wahib. Tempograms are plotted in order to show the estimated BPM of the track along its duration.

The *tempo* feature of the Spotify API estimates a **BPM of 111.943** (rounded 112 BPM).

The first Tempogram doens't explicitly reflect the estimation of the Spotify API, tempi of around 210-220 and 430-450 are shown in the plot. The plot might record the represent half-time and quarter time BPM's of 224 and 448 (based on the estimation of 112 BPM).

The second Tempogram (cyclic), is adjusted to represent the more 'common' tempi at which humans tap. This plot does reflect the Spotify API estimation of 112 BPM more clearly.

At the 75 second mark, there is a slight drop and increase in tempo. From this point, noticable is the tape stop sound effect, which is immediately followed by the bridge. The BPM however, remains the same (try to tap along).

***

```{=html}
<object data="https://open.spotify.com/embed/track/7jnaow1bGpKO2VkgtYE8Vv" width="280" height="140">
    <embed src="https://open.spotify.com/embed/track/7jnaow1bGpKO2VkgtYE8Vv" width="280" height="140"></embed>
    Error: Embedded data could not be displayed.
</object>
```



<!-- Frame 10 -->

### `r shiny::icon("exclamation-triangle")` ***NEW!***<br>10. Most prevalent beats:<br>Tempi around **100 BPM** and **120 BPM** most common in corpus.

```{r, echo = FALSE}
pc <- corpus_df %>%
  group_by(year...31) %>%
  summarize(tempo, mode = recode_factor(mode,
                              `0` = as.character("Minor"),
                              `1` = as.character("Major")))
p10_1 <- pc %>%  
#ggplot(aes(x = key_key, fill = as.factor(mode))) +
ggplot(aes(x = tempo, fill = year...31)) +
  #facet_wrap(~ year...31) +
  scale_fill_viridis_d(
    alpha = 0.7,
    begin = 0.2,
    end = 0.9,
    option = "D",
    name = "Year",
    # labels = c("Minor", "Major")
  ) +
  labs(
    x = "BPM",
    title = "Tempo frequency in corpus",
    subtitle = "") +
  theme_light() +
  scale_x_continuous(breaks = seq(40, 210, by = 20)) +
  #geom_histogram(stat = "count")
  geom_density(alpha = 0.475)

# p9_2 <- pc %>%  
# ggplot(aes(x = key_key, fill = as.factor(mode))) +
#   facet_wrap(~ year...31) +
#   scale_fill_viridis_d(
#     alpha = 0.7,
#     begin = 0.6,
#     end = 0.9,
#     option = "D",
#     name = "Mode",
#     labels = c("Minor", "Major")
#   ) +
#   labs(
#     x = "Key",
#     y = "Density",
#     title = "Normalized key occurrences in corpus per year",
#     subtitle = "") +
#   theme_light() +
#   #geom_histogram(aes(y=..count../sum(..count..)), stat = "count", alpha=0.6, position="identity")
#   geom_histogram(aes(y=(..count..)/tapply(..count..,..PANEL..,sum)[..PANEL..]), stat = "count") #+
#   #scale_y_continuous(labels=percent_format())
# 
# ply1_1 <- ggplotly(p9_1, width = 1050, height = 525)
# ply9_2 <- ggplotly(p9_2, width = 1050, height = 525)

#knitr::include_graphics("figure/hist.png")

# ply10_1 <- 
  
ggplotly(p10_1)

averageBPM <- corpus_df %>%
  summarize(mean_tempo = mean(tempo))

# vb10 <- flexdashboard::valueBox(round(averageBPM$mean_tempo), icon="fa-music")

# grid.arrange(
#   arrangeGrob(
#     ply10_1,
#     vb10,ncol = 2),
#   nrow = 1)
```

***

The density plot shows that overall the the most frequent tempi within the corpus is around 90-100 BPM and 115-128 BPM.
The year **2019** showed a strong preference for tracks around **98 BPM** and to a lesser extent **123 BPM**.

The year **2020** showed a strong preference for tracks around both **95 BPM** and **121 BPM**.

The first **7 weeks of 2021** showed a preference for tracks around **99 BPM** and **122 BPM**.


***

**Average Tempo:**

```{js, echo = FALSE}
var divs = ["id2019", "id2020", "id2021"];
var visibleDivId = null;

function toggleVisibility(divId) {
  if (visibleDivId === divId) {
    visibleDivId = null;
  } else {
    visibleDivId = divId;
  }

  hideNonVisibleDivs();
}

function hideNonVisibleDivs() {
  var i, divId, div;

  for (i = 0; i < divs.length; i++) {
    divId = divs[i];
    div = document.getElementById(divId);

    if (visibleDivId === divId) {
      div.style.display = "block";
    } else {
      div.style.display = "none";
    }
  }
}
```

```{css, echo = FALSE}
.btn1 {
  border: none;
  background-color: rgba(29, 185, 84, 0.8);
  padding: 14px 26px;
  font-size: 16px;
  cursor: pointer;
  display: inline-block;
  color: white;
  transition: 0.3s;
}

.btn1:hover {
  # background-color: rgba(29, 185, 84, 0.8);
  background-color: rgba(47, 71, 79, 0.7);
  color: white;
}

.b2019 {
  color: rgba(44, 62, 80, 1);
  background-color: #c0c1d7;
}

.b2020 {
  color: rgba(44, 62, 80, 1);
  background-color: #b4ded8;
}

.b2021 {
  color: rgba(44, 62, 80, 1);
  background-color: #e8f4b7;
}

#id2019 {
  display: none;
  transition: 0.3s;
  #background-color: rgba(191, 191, 191, 0.7);
  background-color: rgba(192, 193, 215, 0.8) !important;
  background-image: url('icons/musical-note(B).png');
  background-repeat: no-repeat;
  background-size: 35%;
  background-position: 100% 70%;
  background-blend-mode: soft-light;
}

#id2020 {
  display: none;
  transition: 0.3s;
  #background-color: rgba(191, 191, 191, 0.7);
  background-color: rgba(180, 222, 216, 0.8) !important;
  background-image: url('icons/musical-note(B).png');
  background-repeat: no-repeat;
  background-size: 35%;
  background-position: 100% 70%;
  background-blend-mode: soft-light;
}

#id2021 {
  display: none;
  transition: 0.3s;
  #background-color: rgba(191, 191, 191, 0.7);
  background-color: rgba(232, 244, 183, 0.8) !important;
  background-image: url('icons/musical-note(B).png');
  background-repeat: no-repeat;
  background-size: 35%;
  background-position: 100% 70%;
  background-blend-mode: soft-light;
}

#box hover

#id2019:hover {
  transition: 0.3s;
  #background-color: rgba(191, 191, 191, 0.7);
  background-color: rgba(192, 193, 215, 1)!important;
  background-image: url('icons/musical-note(W).png') !important;
  background-repeat: no-repeat;
  background-size: 35%;
  background-position: 100% 70%;
  background-blend-mode: soft-light;
}

#id2020:hover {
  transition: 0.3s;
  #background-color: rgba(191, 191, 191, 0.7);
  background-color: rgba(180, 222, 216, 1) !important;
  background-image: url('icons/musical-note(W).png');
  background-repeat: no-repeat;
  background-size: 35%;
  background-position: 100% 70%;
  background-blend-mode: soft-light;
}

#id2021:hover {
  transition: 0.3s;
  #background-color: rgba(191, 191, 191, 0.7);
  background-color: rgba(232, 244, 183, 1) !important;
  background-image: url('icons/musical-note(W).png');
  background-repeat: no-repeat;
  background-size: 35%;
  background-position: 100% 70%;
  background-blend-mode: soft-light;
}

```

```{=html}
<div class="storyboard-nav">
  <div class="sbframelist" style="overflow: hidden;width: 100%;">
    <ul style="transform: translateZ(0px); width: 270px;">
      <li id="id2019" class="box"><h2>117</h2><h4>BPM</h4></li>
      <li id="id2020" class="box"><h2>116</h2><h4>BPM</h4></li>
      <li id="id2021" class="box"><h2>121</h2><h4>BPM</h4></li>
    </ul>
  </div>    
</div>
<div>
  <button class="btn1 b2019" onclick="toggleVisibility('id2019')">2019</button>
  <button class="btn1 b2020" onclick="toggleVisibility('id2020')">2020</button>
  <button class="btn1 b2021" onclick="toggleVisibility('id2021')">2021</button>
</div>



<!-- <button class="btn1 b2019" onclick="toggleVisibility('2019')">2019</button> -->
<!-- <button class="btn1 b2020" onclick="toggleVisibility('2020')">2020</button> -->
<!-- <button class="btn1 b2021" onclick="toggleVisibility('2021')">2021</button> -->
```
*Press one of these buttons to display the average BPM*

<!-- Frame 1 -->

### 1. **Did Spotify users in the Netherlands change their music listening behavior during the COVID-19 pandemic?**

#### **Computational Musicology Portfolio**

The COVID-19 pandemic has stirred society up by quite large margin. Many people are (in)directly by the health crisis or the resulting governmental measures. Leading to societal adjustments, e.g. social distancing and isolation, causing society to change communication, work and more aspects of daily life. This dashboard will explore the main question below.

> Did Spotify users in the Netherlands change their music listening behavior during the COVID-19 pandemic?

A corpus has been be created to perform various computational musicological analyses using the [spotifyr](https://www.rcharlie.com/spotifyr/){target="_blank"} and [compmus](https://jaburgoyne.github.io/compmus/){target="_blank"} packages. 
The listening behavior of Spotify users in the Netherlands before and during the COVID-19 pandemic will be considered, as measured by the Spotify API. In addition, specific events and times will be highlighted in order to find out to what extent changes in listening behavior can be attributed to these events (e.g. lockdown and curfew).

**Corpus**

In order to analyze general listening behavior, the most important variables for the analyses are:

- Playlist
- Spotify Audio Features
- Time
- [COVID-19 variables provided by RIVM (The Dutch National Institute for Public Health and the Environment)](https://data.rivm.nl/covid-19/){target="_blank"}

**Playlist**

In order to keep track on the average listening behavior of Dutch Spotify users, the weekly ‘Top 50’ and ‘Viral 50’ playlists from the Netherlands will be analyzed over time. The year 2019 will be measured from week 45, the year 2020 in its entirety, and 2021 is measured until week 7.

Thus,<br>
2019 contains 8 playlists consisting of 50 observations (tracks)<br>
2020 contains 53 playlists consisting of 50 observations (tracks)<br>
2021 contains 7 playlists consisting of 50 observations (tracks)

Since Spotify autoupdates their playlists, the historical 'Top 50' lists in the form of CSV files will be retrieved from [Spotify Charts](https://spotifycharts.com/regional/nl/weekly/latest){target="_blank"}.

**Spotify Audio Features**

The changes of (or lack thereof) listening behavior will be measured by the the different Spotify Audio Features:

<details>

<summary>**▶ Spotify Audio Features:**</summary>

- danceability
- energy
- key
- loudness
- mode
- speechiness
- acousticness
- instrumentalness
- liveness
- valence
- tempo
- duration_ms

Also the following features obtained through the Spotify API will be analyzed:

- Number of streams
- Position
- Track Name
- Artist
- Streams

</details>

The mean of each variable of the 50 tracks will be calculated, outliers and other interesting tracks in the dataset will be highlighted as well.

**Time**

The variable time will be used to identify the different weeks as well as the periods before and during the pandemic that may explain the changes in music listening behavior from the top and viral playlists. In addition interesting annual periods will be isolated to see if similar patterns reoccur during the pandemic.For example, the December Holiday season before and during the pandemic will be analyzed to identify whether Spotify users altered their Christmas related listening behavior.

- Week
- Year

**COVID-19 variables**

Alongside the musical analyses the statistics concerning COVID-19 will be taken into account. The data is provided by the The Dutch National Institute for Public Health and the Environment (RIVM). The data has been pre-processed to include weekly and cumulative data. The variables that are included in this dashboard are the following variables:

- Hospital Admissions
- Number of deaths
- Reported cases of COVID-19


<!-- Frame 2 -->

### 2. A trip down memory lane:<br>**What were people in the Netherlands listening to before the pandemic?**<br><br>*Note: tentative*

```{r, echo = FALSE}
# all2019f = list()
# all2019 = list()
# 
# for(m in sorted_fweeks2019){
#     datm <- get(m) %>%
#         summarize(danceability,energy,key,loudness,mode,speechiness,acousticness,instrumentalness,
#                   liveness,valence,tempo,duration_minute = duration_ms/1000/60, year, week = as.factor(week),
#                   mean_dance = mean(danceability),
#                   mean_energy = mean(energy),
#                   mean_key = mean(key),
#                   mean_loudness = mean(loudness),
#                   mean_mode = mean(mode),
#                   mean_speechiness = mean(speechiness),
#                   mean_acousticness = mean(acousticness),
#                   mean_instrumentalness = mean(instrumentalness),
#                   mean_liveness = mean(liveness),
#                   mean_valence = mean(valence),
#                   mean_tempo = mean(tempo),
#                   mean_duration_minute = mean(duration_ms/1000/60))
#     all2019f[[m]] <- datm
# }
# 
# for(o in sorted_weeks2019){
#     dat <- get(o) %>%
#         summarize(Position, Streams, `Track Name`, Artist, Streams, year, week,
#                   mean_streams = mean(Streams),
#                   min_streams = min(Streams),
#                   max_streams = max(Streams),
#                   top_track = head(paste(`Track Name`,"-" , Artist), 1)
#                   )
#     all2019[[o]] <- dat
# }
# 
# 
# big_all2019f <- dplyr::bind_rows(all2019f)
# big_all2019 <- dplyr::bind_rows(all2019)
# 
# join_big2019 <- dplyr::bind_cols(big_all2019f, big_all2019)
# 
# #big_all2019 = do.call(rbind, all2019)


sd_19 <- SharedData$new(join_big2019)
fls <- filter_slider("ps", "Position", sd_19, "Position", step = 1)
flc <- filter_checkbox(id = "wk", label = "Week", sharedData = sd_19, group = ~week...14, inline = TRUE)
flc2 <- filter_checkbox(id = "md", label = "Mode", sharedData = sd_19, group = ~mode, inline = TRUE)

p1 <- ggplot(sd_19, aes(x = valence, y = energy, colour = week...14, label = `Track Name`, label2 = Artist)) +
  #geom_point(aes(size = danceability, alpha = 0.4, fill = week...14)) + 
  geom_point(aes(size = danceability, fill = week...14), alpha = 0.3) +  
  theme_light() 
p2 <- ggplot(sd_19, aes(x = week...14, y = valence, colour = week...14, label = `Track Name`, label2 = Artist, group = 1)) +
  #geom_point(aes(alpha = 0.9)) +
  geom_point(alpha = 0.2) +
  geom_line(aes(y = mean_valence, group = 1, alpha = 0.1), color = "black") +
  #geom_point(aes(y = mean_valence, alpha = 1)) +
  geom_point(aes(y = mean_valence, group = 1), shape = 22, size = 2) +
  labs(x = "Week") + theme_light()

# bscols(widths = c(2,5,5),
#        list(fls,
#             fls2,
#             flc,
#             flc2),
#   ggplotly(p1),
#   ggplotly(p2)
# )

bscols(ggplotly(p1),
       ggplotly(p2)
       )

```

***

`r bscols(list(fls,flc,flc2))`

***

A full analysis of the period before the pandemic (2019) will follow when the relevant plots are completed.

<!-- Frame 3 -->

### 3. **Covid-19 & Music trends**: Music trends show periodical listening pattern

```{r, echo = FALSE}

comb_data.long <- melt(comb_data, id.vars = c("week", "year...13", "week_year", "max_streams", "min_streams", "mean_streams", "top_track"), measure.vars = c("deceased", "hospital_admission"))

coeff <- 1000


p <- ggplot(comb_data.long, aes(x = week_year, label = max_streams, label2 = min_streams, label3 = top_track)) +
  geom_line(aes(x = factor(week_year), y = max_streams/coeff, group = 1, color = "Streams Top 1 track"),
            alpha = 0.7, size = 1) +
  geom_point(aes(y = max_streams/coeff, color = "Streams Top 1 track" ), group = 1, alpha = 1, size = 1) +
  geom_line(aes(x = factor(week_year), y = mean_streams/coeff, group = 2, color = "Average Streams of Top 50"),
            alpha = 0.7, size = 1) +
  geom_point(aes(y = mean_streams/coeff, color = "Average Streams of Top 50"), group = 2, alpha = 1, size = 1) +
  geom_bar(aes(y = value, fill = variable), stat = "identity") +
  
  geom_vline(xintercept = 64, linetype="dotted", size = 0.5, alpha = 0.5) +
    annotate("text", label = "<b>1st lockdown</b>\n'Intelligent'\nLockdown", x = 63, y = 4000, size = 3) +

  geom_vline(xintercept = 94, linetype="dotted", size = 0.5, alpha = 0.5) +
    annotate("text", label = "<b>2nd lockdown</b>\nPartial\nLockdown", x = 92, y = 4000, size = 3) +

  geom_vline(xintercept = 103, linetype="dotted", size = 0.5, alpha = 0.5) +
    annotate("text", label = "<b>3rd lockdown</b>\nHard\nLockdown", x = 101, y = 4000, size = 3) +

  geom_vline(xintercept = 107, linetype="dotted", size = 0.5, alpha = 0.5) +
    annotate("text", label = "Curfew", x = 105, y = 4000, size = 3) +

  scale_color_manual(name = "Variables", values = c("Streams Top 1 track" = "#33618d",
                                                    "Average Streams of Top 50" = "#440d57")) +
  
  scale_x_discrete(label=function(x){
    return(str_replace(x,"_20","\n'"))
    }) +
  
  scale_y_continuous(
    
    name = "Number of Hospitalized and Deceased\nNumber of Streams: Average & Top 1 Track (*1,000)",
    
    # Add a second axis and specify its features
    #sec.axis = sec_axis(trans = ~ . * coeff, name="Number of Streams of Top 1 track")
    expand = expansion(mult = c(0, 0))
  )+
  
   # scale_color_viridis_d(
   #  begin = 0,
   #  end = 0.3,
   #  option = "B",
   #  alpha = 0.75,
   #  guide = NULL,
   #  direction = 1
   #  ) +
  
  scale_fill_viridis_d(
    begin = 0.7,
    end = 0.9,
    option = "D",
    alpha = 0.75,
    guide = NULL,
    direction = -1,
    name = "Variables",
    labels = c("Deceased", "Hospital admissions")
    ) +
  
  theme_light() +
  labs(
    x = "Week, Year",
    title = "Spotify and Covid trends",
    subtitle = "Trends from 2019 to 2021"
  ) +

  theme(axis.title.y = element_text(size=13),
        axis.title.y.right = element_text(size=13),
        #axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)
        )


l1 <- list(
  source=base64enc::dataURI(file = "icons/House-lockdown (1).png"),
  x = 62.5, y = 1, sizex = 3, sizey = 0.05,
  xref = "x", yref = "paper",
  xanchor = "left", yanchor = "bottom"
  )
l2 <- list(
  source=base64enc::dataURI(file = "icons/House-lockdown (1).png"),
  x = 92.5, y = 1, sizex = 3, sizey = 0.05,
  xref = "x", yref = "paper",
  xanchor = "left", yanchor = "bottom"
  )
l3 <- list(
  source=base64enc::dataURI(file = "icons/House-lockdown (1).png"),
  x = 101.5, y = 1, sizex = 3, sizey = 0.05,
  xref = "x", yref = "paper",
  xanchor = "left", yanchor = "bottom"
  )
l3cf <- list(
  source=base64enc::dataURI(file = "icons/Time (1).png"),
  x = 105.5, y = 1, sizex = 3, sizey = 0.05,
  xref = "x", yref = "paper",
  xanchor = "left", yanchor = "bottom"
  )

ggplotly(p, dynamicTicks = TRUE) %>%
  add_lines() %>%
  rangeslider(start = str_replace("45_2019","_20","\n'"), end = str_replace("6_2021","_20","\n'")) %>%
  layout(images = list(l1,l2,l3,l3cf))


```


***

#### The first case(s)
On February 27th, 2020 (week 9), the first case of COVID-19 had been confirmed in the Netherlands.
Before this occurrence, when everything was normal, the number of streams of the top songs decreased until the end of the holiday season. Probably due people coming together to enjoy (the holiday) music, movies or other activities together, instead of individually. In the first few weeks of 2021 the number of streams started rising again.  

From week 5 the number of top streams started to decline. And even When the first cases, the first admissions into the hospitals, and first deaths were reported the number continued to decline.

#### Togetherness and solidariy during lockdown
As the situation became more severe, with record COVID-related hostpital admissions in week 13, the [Dutch government implemented the first lockdown: the 'intelligent' lockdown](https://en.wikipedia.org/wiki/COVID-19_pandemic_in_the_Netherlands){target="_blank"} (first dotted line). This led to relative high public solidarity towards those affected by the virus, especially essential workers. This may explain the sudden spike of both Top 1 and average streams. The Top 1 rose from 1,598,458 to a record 3,482,822 streams within two weeks, with the song 17 Miljoen Mensen - Live @538 in Ahoy by Davina Michelle topping the charts for five consecutive weeks. 17 Miljoen Mensen (17 Million people) [was dedicated to the people affected by the virus](https://www.ad.nl/show/davina-michelle-en-snelle-brengen-17-miljoen-mensen-uit~a9bdeb0e){target="_blank"}. So this spike is most likely related to the virus and its effects.



<!-- Frame 4 -->

### 4. Top streamed tracks: Consistent hits and one hit wonders. **Difficult to classify most popular song**<br>*Note: tentative* 

```{r, echo = FALSE}
require(flexdashboard)
require(shinydashboard)
require(shiny)

top_tot_streams <- distinct(
  traxjoin %>% group_by(top_track) %>% 
    summarize(tot_streams, 
              number_weeks_top1 = n,
              avg_topstream_topweek = round((tot_streams/n), digits = 0)) %>% 
    arrange(desc(tot_streams))
  )

top_tot_streams_t <- top_tot_streams

names(top_tot_streams_t)[1] <- "Track name - Artist"
names(top_tot_streams_t)[2] <- "Total Streams"
names(top_tot_streams_t)[3] <- "Number of weeks at Top 1"
names(top_tot_streams_t)[4] <- "Average Streams per week on Top 1"

top_table <- datatable(top_tot_streams_t)

p_t <- ggplot(comb_data_trax, aes(x = max_streams, y = fct_rev(week_year), label = factor(paste(top_track, "|", n,
                                                                                         "weeks")))) +
  #geom_count(aes(size = n), group = 1, stat = "identity") +
  geom_text(aes(color = factor(top_track))) + 
  #geom_text(aes(color = n)) +
  #geom_text(aes(label = paste(top_track, n))) +
  #geom_line(aes(x = max_streams, y = fct_rev(week_year)), alpha = 0.05, group = 1, size = comb_data_trax$n) +
  geom_point(alpha = 0.2) + 
  theme_light()   
  #scale_color_viridis_d()
  #scale_color_viridis_c()

# tabBox(width=NULL,
#        height = 1000,
#        title = tagList(shiny::icon("virus"),shiny::icon("spotify"),"Top Tracks"),
#        id = "tabset2",
#        tabPanel("Top Streams", top_table),
#        tabPanel("Top 1 Tracks per week", ggplotly(p_t, width = 1450, height = 725))
#        )

tabBox(width=NULL,
       height = 1000,
       title = tagList(shiny::icon("virus"),shiny::icon("spotify"),"Top Tracks"),
       id = "tabset2",
       tabPanel("Top Streams", top_table)
       )

```

***

In the corpus there are a total of 20 distinct tracks topping that charts in a span of 68 weeks. On average a Top 1 track remains for `r mean(top_tot_streams$number_weeks_top1)` weeks on the number 1 spot, while streamed `r round(mean(top_tot_streams$tot_streams))` times, and `r round(mean(top_tot_streams$avg_topstream_topweek))` times per week on the Top 1 spot.

##### The most popular track
This gives an interesting insight to the weekly most popular songs in this corpus. But which track is the most popular? Since the corpus is time constrained, solely considering the number of streams might not show the full picture. Therefore, three variables are considered:

1.	Total number of streams while on Top
2.	Number of weeks on Top
3.	Average streams while on Top per week on Top

The most popular song according to variable 1 is “Dance Monkey” by Tones And I, with a total of 15,872,577 streams while at number 1. The other variables (v2 = 8 weeks | v3 = 1,984,072 per week) show that the track performs above average and can indeed be considered popular.

According to variable 2, “Mood (feat. iann dior)” by 24kGoldn is the most popular, topping the charts for a total of 9 weeks. The other variables (v1 = 15,498,940 | v3 = 1,722,104 per week) show that it is significantly popular under v1, but barely underperforms under v3.

Variable 3 shows “Tigers” by Bilal Wahib is streamed the most per week while on top with 2,652,339 streams. The track underperforms on the other variables (v1 = 5,304,679 | v2 = 2 weeks). Thus, this song can be considered a viral hit or more harshly a “one hit wonder” lasting two weeks.

There are limitations to this approach, only the number one spots are considere. For a clearer picture,a wider range is recommended. The tracks “Dance Monkey” and “Mood” performed quite similarly. It remains difficult to denote which song is the most popular.

<!-- Frame 5 -->

### 5. 17 Miljoen Mensen vs. 15 Miljoen Mensen - The prominent cover song during the pandemic shows **little similarity with original** {data-commentary-width="50%"}

```{r, include = FALSE}
## 17 Miljoen
miljoen_17 <-
  get_tidy_audio_analysis("7e42rjxCt8tPjglU9VyBcz") %>%
  select(segments) %>%
  unnest(segments) %>%
  select(start, duration, pitches)

miljoen_17f <- get_track_audio_features("7e42rjxCt8tPjglU9VyBcz")

## 15 Miljoen
miljoen_15 <-
  get_tidy_audio_analysis("2GBJFvDr62eIX24a3t6pBr") %>%
  select(segments) %>%
  unnest(segments) %>%
  select(start, duration, pitches)

miljoen_15f <- get_track_audio_features("2GBJFvDr62eIX24a3t6pBr")

miljoen_17f <- as.data.frame(t(miljoen_17f))
miljoen_15f <- as.data.frame(t(miljoen_15f))
miljoen_f <- cbind(miljoen_17f,miljoen_15f)
miljoen_f <- miljoen_f[-(12:16),]
row.names(miljoen_f)[12] <- "duration_sec"
miljoen_f[12,] <- as.integer(miljoen_f[12,])/1000

names(miljoen_f) <- c("17 Miljoen Mensen (2020)", "15 Miljoen Mensen (1996)")

miljoen_17c <- miljoen_17 %>%
  mutate(pitches = map(pitches, compmus_normalise, "euclidean")) %>%
  compmus_gather_chroma() %>% 
  ggplot(
    aes(
      x = start + duration / 2,
      width = duration,
      y = pitch_class,
      fill = value
    )
  ) +
  geom_tile() +
  labs(x = "Time (s)", y = NULL, fill = "Magnitude", title = "17 Million (2020)") +
  theme_minimal() +
  scale_fill_viridis_c()

miljoen_15c <- miljoen_15 %>%
  mutate(pitches = map(pitches, compmus_normalise, "euclidean")) %>%
  compmus_gather_chroma() %>% 
  ggplot(
    aes(
      x = start + duration / 2,
      width = duration,
      y = pitch_class,
      fill = value
    )
  ) +
  geom_tile() +
  labs(x = "Time (s)", y = NULL, fill = "Magnitude", title = "15 Million (1996)") +
  theme_minimal() +
  scale_fill_viridis_c()

miljoen_p <- compmus_long_distance(
  miljoen_15 %>% mutate(pitches = map(pitches, compmus_normalise, "euclidean")),
  miljoen_17 %>% mutate(pitches = map(pitches, compmus_normalise, "euclidean")),
  feature = pitches,
  method = "cosine"
) %>%
  ggplot(
    aes(
      x = xstart + xduration / 2,
      width = xduration,
      y = ystart + yduration / 2,
      height = yduration,
      fill = d
    )
  ) +
  geom_tile() +
  coord_equal() +
  labs(x = "15 Milljoen mensen (1996)", y = "17 Miljoen mensen (2020)") +
  theme_minimal() +
  scale_fill_viridis_c(guide = NULL)



```

```{r Plots, echo = FALSE}
miljoen_15cl <- miljoen_15c + theme(legend.position = "none")

grid.arrange(miljoen_p, # First row with one plot spanning over 2 columns
             arrangeGrob(miljoen_17c, miljoen_15cl, ncol = 2), # Second row with 2 plots in 2 different columns
             nrow = 2)  
```

***

The track "17 Miljoen Mensen" (2020) is a cover of "15 Miljoen Mensen" (1996), which was released 24 years earlier! An analysis of the chromafeatures of the two tracks made in order to find similarities between them. Instantly noticed differences are 17 Miljoen mensen's title adjustment for the population increase of 2 million people, and its shortness with a duration of just 1 minute and 47 seconds.

The first plot shows the Dynamic Time Warping of the two tracks, using Euclidean norm and angular distance. A diagonal pattern would denote similarity between the two tracks. This is not observed, which implies significant differences. For instance, the table below shows that pitch classes differ. According to the Spotify API, "17 Miljoen Mensen" is in the key of G major, wheras "15 Miljoen Mensen" is in the key of C major. This is not explicitly shown, but they are represented in their respective chromagrams.

The tracks do share a   In addition the 'sound and feel' of the tracks differ: 15 miljoen mensen has a higher danceability, energy, and loudness, whereas "17 miljoen mensen" has a much higher acousticness and liveness (due to the recording being a live performance). A remarkable commonality probably explains the differences: Both tracks were unintended single releases, ["15 miljoen mensen" was initially written for a commercial, and "17 Miljoen mensen" as a tribute for a (due to COVID-19) canceled music concert](https://nl.wikipedia.org/wiki/15_miljoen_mensen){target="_blank"}. The different motivations behind the tracks reflects the different 'sound and feel' as shown by Spotify API.

`r knitr::kable(miljoen_f)`

***

```{=html}
<object data="https://open.spotify.com/embed/playlist/3wraxQVN9Z6PmTk7wEA6wR" width="280" height="140">
    <embed src="https://open.spotify.com/embed/playlist/3wraxQVN9Z6PmTk7wEA6wR" width="280" height="140"></embed>
    Error: Embedded data could not be displayed.
</object>
```



<!-- Frame 6 -->

### 6. All I Want *be*for*e* Christmas... is Christmas<br>**Earlier Christmas in 2020** due to the lockdown.

```{r, echo = FALSE}
# p <- ggplot(data2020, aes(mean_valence, mean_energy, size = mean_dance, color = mean_tempo, label = week_year))
# 
# ggplotly(p + geom_point())

z <- comb_data %>%
  filter(year...26 %in% c(2019, 2020)) %>%
  filter(week %in% c(45:53))

z_a <- z %>% 
  filter(year...26 == 2020) %>%
  filter(week %in% c(50:53))

ann_1 <- data.frame(mean_valence = 0.6,mean_energy = 0.5868,
                       year...26 = factor(2020,levels = c(2019,2020)),
                       top_track = "all i want")
ann_2 <- data.frame(mean_valence = 0.6,mean_energy = 0.5868,
                       year...26 = factor(2019,levels = c(2019,2020)),
                       top_track = "all i want")

#p <- ggplot(z, aes(mean_valence, mean_energy, color = mean_tempo, label = week_year, label2 = top_track)) +
p <- ggplot(z, aes(mean_valence, mean_energy, label = top_track)) +
  geom_point(aes(size = mean_dance, color = mean_tempo)) +
  geom_text(aes(label = week), vjust = 0, nudge_y = 0.003, nudge_x = 0.003) +
  facet_grid(. ~ year...26)+
  scale_colour_viridis_c(
    option = "D",
    alpha = 0.75,
  ) +
  theme_light() +
  labs(
    x = "Mean Valence",
    y = "Mean Energy",
    title = "Audio features per week in 2019 and 2020",
    subtitle = "Christmas music increases average valence and decreases average energy in Top 50 playlist"
  )

p1 <- p + 
  #geom_point(ann_1, mapping = aes(mean_valence, mean_energy), size = 35, alpha = 0.03) +
  geom_text(ann_1, mapping =  aes(x=0.57, y=0.57, label="<i>All I Want for Christmas Is You</i>", check_overlap = TRUE)) +
  geom_text(ann_2, mapping =  aes(x=0.57, y=0.558, label="<i>All I Want for Christmas Is You</i>", check_overlap = TRUE))

p1 <- p1 + stat_ellipse(mapping = aes(mean_valence, mean_energy), data = z_a, linetype = 1)

ggplotly(p1)
   
```

***

Christmas songs started to dominate the charts in 2020 from around week 49 until week 53, whereas in 2019 Christmas this phenomenon occurred later. In 2020 it is noticeable that the bottom right corner contain tracks with relatively high BPM, high valence, low energy and low danceability.Duruing these weeks Christmas tracks dominated the charts. In 2019 this phenomenon is very noticeable in week 52, but shows that Christmas slowly started in week 50. Also in 2020, the charts remained similar during the holiday period from week 50 to 53, whereas in 2019 week 52 saw a spike of the Christmas related audio features. This pattern implies more Christmas tracks entered the Top 50.

Interestingly, Mariah Carey's 'All I Want for Christmas' topped the charts for four consecutive weeks in 2020, as opposed to 1 week in 2019.

A Possible explanation is that due to the imposed lockdown and other restrictions, people may have felt a need or desire for the "Christmas Spirit" or "Christmas Vibes" a week earlier than in 2019.

Another interesting discovery is that similar to 2019, the top streams in 2020 decreased in similar fashion. A possible explanation is that people disregarded the lockdown regulations and spent the holiday season with friends and/or family or were preoccupied with other activities to keep in touch with them.

<!-- Frame 7 -->

### 7. Self-Similarity Matrix: "Dance Monkey" **Shows repeating pattern and noticeably distinct Millennial Whoop**
```{r, include = FALSE}
dancemonkey <-
  get_tidy_audio_analysis("1rgnBhdG2JDFTbYkYRZAku") %>% # Change URI.
  compmus_align(bars, segments) %>%                     # Change `bars`
  select(bars) %>%                                      #   in all three
  unnest(bars) %>%                                      #   of these lines.
  mutate(
    pitches =
      map(segments,
        compmus_summarise, pitches,
        method = "rms", norm = "euclidean"              # Change summary & norm.
      )
  ) %>%
  mutate(
    timbre =
      map(segments,
        compmus_summarise, timbre,
        method = "mean", norm = "euclidean"              # Change summary & norm.
      )
  )
```


```{r, include = FALSE}
# Cepstrogram
cep <- dancemonkey %>%
  compmus_gather_timbre() %>%
  ggplot(
    aes(
      x = start + duration / 2,
      width = duration,
      y = basis,
      fill = value
    )
  ) +
  geom_tile() +
  labs(x = "Time (s)", y = NULL, fill = "Magnitude", title = "Dance Monkey - Tones And I", subtitle = "Cepstrogram: Timbre") +
  scale_fill_viridis_c() +                              
  theme_classic()
```

```{r, include = FALSE}
# Self-Similarity Matrix Pitch
ssm_p <- dancemonkey %>%
  compmus_self_similarity(pitches, "cosine") %>% 
  ggplot(
    aes(
      x = xstart + xduration / 2,
      width = xduration,
      y = ystart + yduration / 2,
      height = yduration,
      fill = d
    )
  ) +
  geom_tile() +
  geom_vline(xintercept = 50, size=1) +
  geom_vline(xintercept = 69, size=1, alpha = 0.5) +
  geom_vline(xintercept = 111, size=1) +
  geom_vline(xintercept = 147, color = "red", size=1) +
  geom_vline(xintercept = 167, color = "red", size=1) +
  coord_fixed() +
  scale_fill_viridis_c(guide = "none") +
  theme_classic() +
  labs(x = "Time (s)", y = "Time (s)", subtitle = "SSM: Pitch")
```

```{r, include = FALSE}
# Self-Similarity Matrix Timbre
ssm_t <- dancemonkey %>%
  compmus_self_similarity(timbre, "euclidean") %>% 
  ggplot(
    aes(
      x = xstart + xduration / 2,
      width = xduration,
      y = ystart + yduration / 2,
      height = yduration,
      fill = d
    )
  ) +
  geom_tile() +
  geom_vline(xintercept = 50, size=1) +
  geom_vline(xintercept = 69, size=1, alpha = 0.5) +
  geom_vline(xintercept = 111, size=1) +
  geom_vline(xintercept = 147, color = "red", size=1) +
  geom_vline(xintercept = 167, color = "red", size=1) +
  coord_fixed() +
  scale_fill_viridis_c(guide = "none") +
  theme_classic() +
  labs(x = "Time (s)", y = "", subtitle = "SSM: Timbre")
```

```{r, echo = FALSE}
# grid.arrange(cep, # First row with one plot spanning over 2 columns
#              arrangeGrob(ssm_p, ssm_t, ncol = 2), # Second row with 2 plots in 2 different columns
#              nrow = 2)

    cep /
(ssm_p | ssm_t)
```

***

##### Dance Monkey
“Dance Monkey” by Tones And I is one of the most popular tracks within the corpus. A structure analysis will show possible patterns of sequences within the track and their relation.

##### Cepstrogram
The first cepstrogram plot shows the magnitude of each timbre feature per segment of the track. The feature c01 is loudness, c02 is low frequency, c03 is mid frequencies. c04 and up are not defined as straight forward, but they may be implied by keeping track of changes within a track during specific segments. The cepstrogram shows that "Dance Monkey’s timbre features are relatively more defined by c01 to c05.

- **c01 Loudness:** The segments reflect the loudness of the track, this is especially noted during the final chorus.
- **c02* Darkness:** The segments faintly show a higher magnitude when the bass drum hits. But its omission is noted much clearly during the breakdown starting at 150 seconds.
- **c03* Mid frequency:** It's shown at about 50 seconds and 165 seconds when higher notes are less and more distinct respectively.
- **c04* Attack:** This is very prevalent during the intro (vocal stretch fade-in sfx).
- **c05* [Unknown]:** It has the highest magnitude at around 150 seconds, noticeable is the loudness of the "[Millenial Whoop](https://en.wikipedia.org/wiki/Millennial_whoop){target="_blank"}".

##### Self Similarity
The second and third plots are Self Similarity Matrices (SSM); The first being pitch, and the second timbre. These plots show the structure of a track by denoting patterns of similarities that reoccur. Diagonal lines and a checkerboard pattern show similarity and repetition.

The timbre SSM is plotted using Euclidean norm, Euclidean distance and summarized by the mean. The plot shows a faint checkerboard pattern which implies some form of repetition in the track. At the 150 second mark there is a significant timbre difference. This is when the breakdown occurs with the earlier mentioned “Millenial Whoop”.

The pitch SSM is plotted using Euclidean norm, cosine distance and summarized by root mean square. This plot shows a slightly more noticeable checkerboard pattern. At the 150 second mark, the plot shows a significant change.

***

```{=html}
<object data="https://open.spotify.com/embed/track/1rgnBhdG2JDFTbYkYRZAku" width="280" height="140">
    <embed src="https://open.spotify.com/embed/track/1rgnBhdG2JDFTbYkYRZAku" width="280" height="140"></embed>
    Error: Embedded data could not be displayed.
</object>
```



<!-- Frame 8 -->

### 8. In the *mood* for which keys?<br>Chord and Key estimations for *"Mood"*.

```{r, echo = FALSE}

mood <-
  get_tidy_audio_analysis("3tjFYV6RSFtuktYl3ZtYcq") %>%
  compmus_align(bars, segments) %>%
  select(bars) %>%
  unnest(bars) %>%
  mutate(
    pitches =
      map(segments,
        compmus_summarise, pitches,
        method = "rms", norm = "euclidean"
      )
  )

mk <- mood %>% 
  compmus_match_pitch_template(
    key_templates,         # Change to chord_templates if descired
    method = "cosine",  # Try different distance metrics
    norm = "euclidean"     # Try different norms
  ) %>%
  ggplot(
    aes(x = start + duration / 2, width = duration, y = name, fill = d)
  ) +
  geom_tile() +
  #scale_fill_viridis_c(guide = "none") +
  scale_fill_viridis_c() +
  theme_minimal() +
  labs(x = "Time (s)", y = "", fill = "d", title = "Mood (feat. iann dior) - 24kGoldn", subtitle = "Keygram")

mc <- mood %>% 
  compmus_match_pitch_template(
    chord_templates,         # Change to chord_templates if desired
    method = "cosine",  # Try different distance metrics
    norm = "euclidean"     # Try different norms
  ) %>%
  ggplot(
    aes(x = start + duration / 2, width = duration, y = name, fill = d)
  ) +
  geom_tile() +
  #scale_fill_viridis_c(guide = "none") +
  scale_fill_viridis_c() +
  theme_minimal() +
  labs(x = "Time (s)", y = "", fill = "d", title = " ", subtitle = "Chordogram")

grid.arrange(
  arrangeGrob(
    mk,
    mc,ncol = 2),
  nrow = 1)

```

***

The track *Mood* by 24kGoldn ft. iann diorr is also one of the identified popular tracks in the corpus.
A keygram and chordogram are plotted in order to show the tonal progression of the track by estimating the chords and key for each segment.

The keygram shows that the key *E♭ major, G minor, F major, C major, G major*, and *C♯minor* are prevalent keys during the track.
The Chordogram show that the chords *C minor, E♭ 7, and E♭ major* are the most prevalent chords of the track. 

**Spotify API**

According to the [Spotify API](https://developer.spotify.com/documentation/web-api/reference/#object-audiofeaturesobject){target="_blank"}, this track is written in the 7th key,  with mode 0: meaning G minor.

**Chordify**

The [Chordify algorithm](https://chordify.net/chords/24kgoldn-mood-official-video-ft-iann-dior-24kgoldnvevo){target="_blank"} identified the chords within the following (4/4) loop:

| E♭ - Gm - | B♭ - F - |


The identified key appears to be on the natural scale:

G - A - B♭ - C - D - E♭ - F

***

```{=html}
<object data="https://open.spotify.com/embed/track/3tjFYV6RSFtuktYl3ZtYcq" width="280" height="140">
    <embed src="https://open.spotify.com/embed/track/3tjFYV6RSFtuktYl3ZtYcq" width="280" height="140"></embed>
    Error: Embedded data could not be displayed.
</object>
```



<!-- Frame 9 -->

### 9. Histogram of Keys within the corpus shows **C♯** as the most common key.


```{r, echo = FALSE}
pc <- corpus_df %>%
  group_by(year...31) %>%
  summarize(key, mode = recode_factor(mode,
                              `0` = as.character("Minor"),
                              `1` = as.character("Major"))) %>%
  mutate(key_key = recode_factor(key,
                              `0` = as.character("C"),
                              `1` = as.character("C\U266F\nD\U266D"),
                              `2` = as.character("D"),
                              `3` = as.character("D\U266F\nE\U266D"),
                              `4` = as.character("E"),
                              `5` = as.character("F"),
                              `6` = as.character("F\U266F\nG\U266D"),
                              `7` = as.character("G"),
                              `8` = as.character("G\U266F\nA\U266D"),
                              `9` = as.character("A"),
                              `10` = as.character("A\U266F\nB\U266D"),
                              `11` = as.character("B")))
    # mutate(key_key = recode_factor(key,
    #                           `0` = "C",
    #                           `1` = "C#",
    #                           `2` = "D",
    #                           `3` = "D#",
    #                           `4` = "E",
    #                           `5` = "F",
    #                           `6` = "F#",
    #                           `7` = "G",
    #                           `8` = "G#",
    #                           `9` = "A",
    #                           `10` = "A#",
    #                           `11` = "B")) %>%
p9_1 <- pc %>%  
ggplot(aes(x = key_key, fill = as.factor(mode))) +
  facet_wrap(~ year...31) +
  scale_fill_viridis_d(
    alpha = 0.7,
    begin = 0.6,
    end = 0.9,
    option = "D",
    name = "Mode",
    labels = c("Minor", "Major")
  ) +
  labs(
    x = "Key",
    title = "Key frequency in corpus per year",
    subtitle = "") +
  theme_light() +
  geom_histogram(stat = "count")

p9_2 <- pc %>%  
ggplot(aes(x = key_key, fill = as.factor(mode))) +
  facet_wrap(~ year...31) +
  scale_fill_viridis_d(
    alpha = 0.7,
    begin = 0.6,
    end = 0.9,
    option = "D",
    name = "Mode",
    labels = c("Minor", "Major")
  ) +
  labs(
    x = "Key",
    y = "Density",
    title = "Normalized key occurrences in corpus per year",
    subtitle = "") +
  theme_light() +
  #geom_histogram(aes(y=..count../sum(..count..)), stat = "count", alpha=0.6, position="identity")
  geom_histogram(aes(y=(..count..)/tapply(..count..,..PANEL..,sum)[..PANEL..]), stat = "count") #+
  #scale_y_continuous(labels=percent_format())

ply9_1 <- ggplotly(p9_1, width = 1050, height = 525)
ply9_2 <- ggplotly(p9_2, width = 1050, height = 525)

#knitr::include_graphics("figure/hist.png")

```

```{r, echo = FALSE}
tabBox(width=NULL,
       height = 1000,
       title = tagList(shiny::icon("music"),"Key frequencies"),
       id = "tabset2",
       tabPanel("Normalized key ocurrences", ply9_2),
       tabPanel("key counts", ply9_1)
       )
```

***

While histogram doesn't show a clear/unanimous preference, the keys **C♯, F♯, G♯** consistently do have a relative high count within the corpus.

In 2019, There is a clear significant higher count of **C♯, F, G, B** key.

In 2020, The keys **C♯, F♯, G♯, B** have a significantly higher frequency in the corpus.

Note that 2021 only contains the first 7 weeks, whereas 2019 and 2020 contain 52 and 53 weeks respectively. Therefore, its not very representative to make the most informed comparisons. 